using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.Mvc;
using System.Xml;
using System.Xml.Serialization;
using PenTester.Objects.Nessus;
using PenTester.Objects.Nmap;
using PenTester.Objects;
using System.Diagnostics;
using Roslyn.Scripting;
using Roslyn.Scripting.CSharp;
using Roslyn.Compilers.CSharp;
using System.IO;
using System.Text;
using System.Reflection;
using PenTester.Models;

namespace PenTester.Controllers
{
    public class HomeController : Controller
    {
        [AllowAnonymous]
        public ActionResult Test()
        {
            string csLoc = @"C:\Users\Ethan\SkyDrive\Code13\PenTester\PenTester\Groups\2\Plugins\68dd3bc4-981a-4d61-994c-780aa8635c51.cs";
            DynamicPlugin output = CreateDynamicPluginObject(csLoc);
            TempData["csFile"] = csLoc;

            return View(output);
        }

        [HttpPost]
        [AllowAnonymous]
        public ActionResult Test(VerifyPluginModel results)
        {
            if (ModelState.IsValid)
            {
                string csLoc = (string)TempData["csFile"];
                UpdateCSFile(csLoc, results);
            }

            return new JsonResult() { Data = new { success = ModelState.IsValid } };
        }

        private void UpdateCSFile(string csFile, VerifyPluginModel userInput)
        {
            SyntaxTree tr = SyntaxTree.ParseFile(csFile);

            CompilationUnitSyntax root = tr.GetRoot();
            SyntaxList<MemberDeclarationSyntax> classes = tr.GetRoot().Members;

            //find Host list
            ClassDeclarationSyntax hostList = (ClassDeclarationSyntax)classes.Where(m => m is ClassDeclarationSyntax)
                                                    .Single(m => ((ClassDeclarationSyntax)m).Identifier.ToString() == userInput.HostList);
            hostList = hostList.AddBaseListTypes(Syntax.ParseTypeName(typeof(IDynamicHostList).FullName));

            //adds a get property for where the Host List is located is
            //needs to be located underneath the Host List Tag
            
            string fieldName = userInput.Host;
            string name = "";
            foreach (PropertyDeclarationSyntax prop in hostList.Members.Where(m => m is PropertyDeclarationSyntax))
            {
                if (prop.Type.ToString().Contains(fieldName))
                {
                    name = prop.Identifier.ToString();
                    break;
                }   
            }
            MemberAccessExpressionSyntax memAcc = Syntax.MemberAccessExpression(SyntaxKind.MemberAccessExpression, Syntax.ThisExpression(), Syntax.IdentifierName(name));
            ReturnStatementSyntax rs = Syntax.ReturnStatement(memAcc);
            SyntaxList<ReturnStatementSyntax> list = Syntax.List(rs);
            BlockSyntax block = Syntax.Block(list);
            AccessorDeclarationSyntax acc = Syntax.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration, block);
            PropertyDeclarationSyntax pd = Syntax.PropertyDeclaration(null, 
                Syntax.Token(SyntaxKind.PublicKeyword), 
                Syntax.ParseTypeName(fieldName + "[]"), 
                null, 
                Syntax.Identifier("Hosts"), 
                Syntax.AccessorList(Syntax.List(acc)));

            hostList = hostList.AddMembers(pd).NormalizeWhitespace();

            //find Host class
            ClassDeclarationSyntax host = (ClassDeclarationSyntax)classes.Where(m => m is ClassDeclarationSyntax)
                                                    .Single(m => ((ClassDeclarationSyntax)m).Identifier.ToString() == userInput.Host);
            host = host.AddBaseListTypes(Syntax.ParseTypeName(typeof(IDynamicHost).FullName));

            fieldName = userInput.OpenPortList;
            foreach (PropertyDeclarationSyntax prop in host.Members.Where(m => m is PropertyDeclarationSyntax))
            {
                if (prop.Type.ToString().Contains(fieldName))
                {
                    name = prop.Identifier.ToString();
                    break;
                }
            }
            memAcc = Syntax.MemberAccessExpression(SyntaxKind.MemberAccessExpression, Syntax.ThisExpression(), Syntax.IdentifierName(name));
            rs = Syntax.ReturnStatement(memAcc);
            list = Syntax.List(rs);
            block = Syntax.Block(list);
            acc = Syntax.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration, block);
            pd = Syntax.PropertyDeclaration(null,
                Syntax.Token(SyntaxKind.PublicKeyword),
                Syntax.ParseTypeName(fieldName + "[]"),
                null,
                Syntax.Identifier("PortList"),
                Syntax.AccessorList(Syntax.List(acc)));

            host = host.AddMembers(pd).NormalizeWhitespace();

            //find port list
            ClassDeclarationSyntax portList = (ClassDeclarationSyntax)classes.Where(m => m is ClassDeclarationSyntax)
                                                    .Single(m => ((ClassDeclarationSyntax)m).Identifier.ToString() == userInput.OpenPortList);
            portList = portList.AddBaseListTypes(Syntax.ParseTypeName(typeof(IDynamicPortList).FullName));

            fieldName = userInput.OpenPortList;
            foreach (PropertyDeclarationSyntax prop in portList.Members.Where(m => m is PropertyDeclarationSyntax))
            {
                if (prop.Type.ToString().Contains(fieldName))
                {
                    name = prop.Identifier.ToString();
                    break;
                }
            }
            memAcc = Syntax.MemberAccessExpression(SyntaxKind.MemberAccessExpression, Syntax.ThisExpression(), Syntax.IdentifierName(name));
            rs = Syntax.ReturnStatement(memAcc);
            list = Syntax.List(rs);
            block = Syntax.Block(list);
            acc = Syntax.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration, block);
            pd = Syntax.PropertyDeclaration(null,
                Syntax.Token(SyntaxKind.PublicKeyword),
                Syntax.ParseTypeName(fieldName + "[]"),
                null,
                Syntax.Identifier("PortList"),
                Syntax.AccessorList(Syntax.List(acc)));

            portList = portList.AddMembers(pd).NormalizeWhitespace();

            //find port class
            ClassDeclarationSyntax port = (ClassDeclarationSyntax)classes.Where(m => m is ClassDeclarationSyntax)
                                                    .Single(m => ((ClassDeclarationSyntax)m).Identifier.ToString() == userInput.OpenPort);
            port = port.AddBaseListTypes(Syntax.ParseTypeName(typeof(IDynamicPort).FullName));

            root.WithMembers(classes);
            string final = root.ToFullString();
        }

        private DynamicPlugin CreateDynamicPluginObject(string csFile)
        {
            bool debugging = true;
            SyntaxTree tr = SyntaxTree.ParseFile(csFile);

            StringBuilder sb = new StringBuilder();
            DynamicPlugin plugin = new DynamicPlugin(((ClassDeclarationSyntax)tr.GetRoot().Members.First(m => m is ClassDeclarationSyntax)).Identifier.ToString());
            int count = 0;
            foreach (ClassDeclarationSyntax classes in tr.GetRoot().Members.Where(m => m is ClassDeclarationSyntax))
            {
                if (classes.Identifier.ToString() == "NewDataSet")
                    continue;

                DynamicPlugin p = null;
                if (count != 0)
                {
                    p = plugin.ObjectExists(classes.Identifier.ToString());
                }
                else
                {
                    p = plugin;
                    count++;
                }
                if (debugging)
                    sb.AppendLine(classes.Identifier.ToString());
                foreach (PropertyDeclarationSyntax prop in classes.Members.Where(cl => cl is PropertyDeclarationSyntax))
                {

                }

                foreach (FieldDeclarationSyntax field in classes.Members.Where(cl => cl is FieldDeclarationSyntax))
                {
                    if (field.ToString().Contains(" string "))
                    {
                        //gets the semicolon token, then the actual identifier
                        string fieldName = field.GetLastToken().GetPreviousToken().ToString().Replace("Field", "");
                        p.AddStringField(fieldName);
                        if (debugging)
                            sb.AppendLine(fieldName);
                    }
                    else
                    {
                        string typeName = field.Declaration.Type.ToString().Replace("[]", "");
                        p.AddObject(typeName);
                        if (debugging)
                            sb.AppendLine(typeName);
                    }
                }
            }
            if (debugging)
            {
                sb.AppendLine(plugin.PrintStructure());
                string text = sb.ToString();

                //output here
                System.IO.FileStream output = System.IO.File.Create(Path.GetDirectoryName(csFile) + "\\test.txt");
                byte[] bytes = UTF8Encoding.UTF8.GetBytes(text);
                output.Write(bytes, 0, bytes.Length);
                output.Close();
            }

            return plugin;
        }

        [AllowAnonymous]
        public ActionResult Index(string id)
        {
            ViewBag.Message = "Modify this template to jump-start your ASP.NET MVC application.";

            if (id == "Awesome")
                ViewBag.Message = "I'm so Awesome!";

            return View();
        }

        public ActionResult About()
        {
            ViewBag.Message = "Your app description page.";

            return View();
        }

        [AllowAnonymous]
        public ActionResult Contact()
        {
            ViewBag.Message = "Your contact page.";

            return View();
        }
    }
}
