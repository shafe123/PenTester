using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Transactions;
using System.Web;
using System.Web.Mvc;
using System.Web.Security;
using DotNetOpenAuth.AspNet;
using Microsoft.Web.WebPages.OAuth;
using WebMatrix.WebData;
using PenTester.Filters;
using PenTester.Models;
using System.Net.Mail;
using System.Net;
using System.Web.Script.Serialization;
using PenTester.Controllers;
using System.Diagnostics;
using Roslyn.Scripting;
using Roslyn.Scripting.CSharp;
using Roslyn.Compilers.CSharp;
using Roslyn.Compilers;
using PenTester.Objects;
using System.Text;

namespace PenTester.Controllers
{
    public class PluginController : Controller
    {
        public ActionResult Index()
        {
            return View();
        }

        public ActionResult Upload(UploadMessageId? message)
        {

            //Cookie cutter from Controllers/AccountControlller.cs, just changed to work with plugins.
            //Question mark is to allow for null values.
            //Good description here http://stackoverflow.com/questions/446835/what-do-two-question-marks-together-mean-in-c
            ViewBag.StatusMessage =
            message == UploadMessageId.UploadPluginSuccess ? "Your Plugin has successfully been uploaded."
            : message == UploadMessageId.UploadPluginFailure ? "Your Plugin was not successfully uploaded."
            : message == UploadMessageId.PluginPathError ? "Your Plugin was not moved to the server."
            : message == UploadMessageId.PluginExistsError ? "The plugin you selected already exists."
            : message == UploadMessageId.UserNotFound ? "Could not verify ID. Plugin not uploaded."
            : "";

            ViewBag.StatusFailure =
                message == UploadMessageId.PluginErrorMessage ? "There was an error uploading your plugin, please try again."
                : "";

            Entities db = new Entities();
            List<Group> groupsUserInArray;

            groupsUserInArray = db.UserProfiles.Single(u => u.UserId == WebSecurity.CurrentUserId).GroupsIn.ToList();

            var model = new PluginModel
            {
                uploadList = groupsUserInArray
            };

            return View(model);
        }

        [HttpPost]
        [ValidateAntiForgeryToken]
        public ActionResult Upload(HttpPostedFileBase fileToUpload, PluginModel plugin)
        {
            if (ModelState.IsValid)
            {
                try
                {
                    Entities db = new Entities();

                    //Get the selected group from the database using the groupId
                    Group uploadGroup = db.Groups.Single(g => g.GroupId == plugin.selectedGroupId);

                    string generated = Guid.NewGuid().ToString();
                    Plugin toUpload = new Plugin()
                    {
                        PluginName = plugin.nameOfUpload,
                        PluginGenerated = generated
                    };
                    uploadGroup.Plugins.Add(toUpload);
                    db.SaveChanges();

                    //xsd.exe requires a '.xml' on the end of the file
                    string filePath = Path.Combine(Server.MapPath("~/Groups/" + plugin.selectedGroupId + "/Plugins"), toUpload.PluginGenerated + ".xml");

                    if (fileToUpload != null)
                    {
                        if (System.IO.File.Exists(filePath))
                        {
                            return RedirectToAction("Upload", "Plugin", new { Message = UploadMessageId.PluginExistsError });
                        }
                        else
                        {
                            try
                            {
                                fileToUpload.SaveAs(filePath);
                            }
                            catch
                            {
                                return RedirectToAction("Upload", "Plugin", new { Message = UploadMessageId.PluginPathError });
                            }
                        }
                        //update the database with successful upload
                        //Load XML into cs file
                        CreateCSFile(filePath);
                        TempData["csLoc"] = filePath.Replace(".xml", ".cs");
                        //present class to user without attributes
                        DynamicPlugin output = CreateDynamicPluginObject(filePath.Replace(".xml", ".cs"));
                        return View("VerifyPlugin", output);
                    }
                }
                catch (Exception)
                {
                    return RedirectToAction("Upload", "Plugin", new { Message = UploadMessageId.UploadPluginFailure });
                }
            }

            //Something is wrong if code execution goes past the try/catch statement.

            return View(plugin);
        }

        [HttpPost]
        public ActionResult VerifyPlugin(VerifyPluginModel model)
        {
            if (ModelState.IsValid)
            {
                //add custom attributes based on user input
                //save class file
                UpdateCSFile((string)TempData["csLoc"], model);

                //dynamically load class as needed
                if (LoadCSIntoAssembly((string)TempData["csLoc"]))
                {
                    return RedirectToAction("Index", "Scans");
                }
            }

            return View("Index");
        }

        private void CreateCSFile(string xmlPath)
        {
            ProcessStartInfo psi = new ProcessStartInfo("C:\\Program Files (x86)\\Microsoft SDKs\\Windows\\v8.0A\\bin\\NETFX 4.0 Tools\\xsd.exe");
            psi.Arguments = xmlPath + " /outputdir:\"" + Path.GetDirectoryName(xmlPath) + "\"";

            System.Diagnostics.Process p = new System.Diagnostics.Process();
            p.StartInfo = psi;
            p.Start();
            p.WaitForExit();

            string xsdPath = xmlPath.Replace(".xml", ".xsd");
            psi.Arguments = xsdPath + " /classes /outputdir:\"" + Path.GetDirectoryName(xmlPath) + "\"";
            p.StartInfo = psi;

            p.Start();
            p.WaitForExit();

            //TODO: delete .xsd and .xml files?
        }
        private DynamicPlugin CreateDynamicPluginObject(string csFile)
        {
            bool debugging = true;
            SyntaxTree tr = SyntaxTree.ParseFile(csFile);

            StringBuilder sb = new StringBuilder();
            DynamicPlugin plugin = new DynamicPlugin(((ClassDeclarationSyntax)tr.GetRoot().Members.First(m => m is ClassDeclarationSyntax)).Identifier.ToString());
            int count = 0;
            foreach (ClassDeclarationSyntax classes in tr.GetRoot().Members.Where(m => m is ClassDeclarationSyntax))
            {
                if (classes.Identifier.ToString() == "NewDataSet")
                    continue;

                DynamicPlugin p = null;
                if (count != 0)
                {
                    p = plugin.ObjectExists(classes.Identifier.ToString());
                }
                else
                {
                    p = plugin;
                    count++;
                }
                if (debugging)
                    sb.AppendLine(classes.Identifier.ToString());
                foreach (FieldDeclarationSyntax field in classes.Members.Where(cl => cl is FieldDeclarationSyntax))
                {
                    if (field.ToString().Contains(" string "))
                    {
                        //gets the semicolon token, then the actual identifier
                        string fieldName = field.GetLastToken().GetPreviousToken().ToString().Replace("Field", "");
                        p.AddStringField(fieldName);
                        if (debugging)
                            sb.AppendLine(fieldName);
                    }
                    else
                    {
                        string typeName = field.Declaration.Type.ToString().Replace("[]", "");
                        p.AddObject(typeName);
                        if (debugging)
                            sb.AppendLine(typeName);
                    }
                }
            }
            if (debugging)
            {
                sb.AppendLine(plugin.PrintStructure());
                string text = sb.ToString();

                //output here
                System.IO.FileStream output = System.IO.File.Create(Path.GetDirectoryName(csFile) + "\\test.txt");
                byte[] bytes = UTF8Encoding.UTF8.GetBytes(text);
                output.Write(bytes, 0, bytes.Length);
                output.Close();
            }

            return plugin;
        }
        private void UpdateCSFile(string csFile, VerifyPluginModel userInput)
        {
            DynamicPlugin dp = CreateDynamicPluginObject(csFile);

            SyntaxTree tr = SyntaxTree.ParseFile(csFile);
            CompilationUnitSyntax root = tr.GetRoot();
            SyntaxList<MemberDeclarationSyntax> classes = tr.GetRoot().Members;
            PropertyDeclarationSyntax pd;
            StringBuilder sb = new StringBuilder();

            foreach (ClassDeclarationSyntax s in (classes.Where(m => m is ClassDeclarationSyntax)))
            {
                //find Host list
                if (s.Identifier.ToString() == userInput.HostList)
                {
                    ClassDeclarationSyntax hostList = s;
                    //add IDynamicHostList inheritance
                    hostList = hostList.AddBaseListTypes(Syntax.ParseTypeName(typeof(DynamicHostList).FullName));

                    //adds a get property for where the Host List is located is
                    //needs to be located underneath the Host List Tag
                    //adds Hosts property to match the interface
                    pd = CreateChildPropertyDeclaration("Hosts", userInput.Host, hostList.Members, typeof(DynamicHost));
                    hostList = hostList.AddMembers(pd);

                    //find class with 'ToolName'
                    pd = CreateStringProperty("ToolName", userInput.ReportName, userInput.HostList, classes, dp);
                    hostList = hostList.AddMembers(pd);

                    sb.AppendLine(hostList.NormalizeWhitespace().ToFullString());
                }
                else if (s.Identifier.ToString() == userInput.Host)
                {
                    //find Host class
                    ClassDeclarationSyntax host = s;
                    //add IDynamicHost inheritance
                    host = host.AddBaseListTypes(Syntax.ParseTypeName(typeof(DynamicHost).FullName));

                    //adds PortList property to match the interface
                    pd = CreateChildPropertyDeclaration("PortList", userInput.OpenPortList, host.Members, typeof(DynamicPortList));
                    host = host.AddMembers(pd);

                    //Adds IP property
                    pd = CreateStringProperty("IP", userInput.HostIP, userInput.Host, classes, dp);
                    host = host.AddMembers(pd);

                    //Adds OperatingSystem
                    if (userInput.HostOS != null)
                        host = host.AddMembers(CreateStringProperty("OperatingSystem", userInput.HostOS, userInput.Host, classes, dp));

                    //Adds Computer Name
                    if (userInput.HostName != null)
                        host = host.AddMembers(CreateStringProperty("Name", userInput.HostName, userInput.Host, classes, dp));

                    sb.AppendLine(host.NormalizeWhitespace().ToFullString());
                }
                else if (s.Identifier.ToString() == userInput.OpenPortList)
                {
                    //find port list
                    ClassDeclarationSyntax portList = (ClassDeclarationSyntax)classes.Where(m => m is ClassDeclarationSyntax)
                                                            .Single(m => ((ClassDeclarationSyntax)m).Identifier.ToString() == userInput.OpenPortList);
                    //adds IDynamicPortList inheritance
                    portList = portList.AddBaseListTypes(Syntax.ParseTypeName(typeof(DynamicPortList).FullName));

                    //adds OpenPorts property to match the interface
                    pd = CreateChildPropertyDeclaration("OpenPorts", userInput.OpenPort, portList.Members, typeof(DynamicPort));
                    portList = portList.AddMembers(pd).NormalizeWhitespace();

                    sb.AppendLine(portList.ToFullString());
                }
                else if (s.Identifier.ToString() == userInput.OpenPort)
                {
                    //find port class
                    ClassDeclarationSyntax port = s;
                    port = port.AddBaseListTypes(Syntax.ParseTypeName(typeof(DynamicPort).FullName));

                    port = port.AddMembers(CreateStringProperty("Number", userInput.PortNumber, userInput.OpenPort, classes, dp));

                    if (userInput.PortProtocol != null)
                        port = port.AddMembers(CreateStringProperty("Protocol", userInput.PortProtocol, userInput.OpenPort, classes, dp));
                    if (userInput.PortSeverity != null)
                        port = port.AddMembers(CreateStringProperty("Severity", userInput.PortSeverity, userInput.OpenPort, classes, dp));
                    if (userInput.PortThreatLevel != null)
                        port = port.AddMembers(CreateStringProperty("ThreatLevel", userInput.PortThreatLevel, userInput.OpenPort, classes, dp));
                    if (userInput.PortDescription != null)
                        port = port.AddMembers(CreateStringProperty("Description", userInput.PortDescription, userInput.OpenPort, classes, dp));

                    sb.AppendLine(port.NormalizeWhitespace().ToFullString());
                }
                else
                {
                    sb.AppendLine(s.NormalizeWhitespace().ToFullString());
                }
            }

            string final = sb.ToString();

            System.IO.File.WriteAllText(csFile, final);
        }
        private PropertyDeclarationSyntax CreateChildPropertyDeclaration(string propertyIdentifierName, string targetFieldName, SyntaxList<MemberDeclarationSyntax> syntaxList, Type returnType)
        {
            //OpenPorts
            //nmaprunHostsPorts
            string name = "";
            foreach (PropertyDeclarationSyntax prop in syntaxList.Where(m => m is PropertyDeclarationSyntax))
            {
                if (prop.Type.ToString().Contains(targetFieldName))
                {
                    name = prop.Identifier.ToString();
                    break;
                }
            }
            MemberAccessExpressionSyntax memAcc = Syntax.MemberAccessExpression(SyntaxKind.MemberAccessExpression, Syntax.ThisExpression(), Syntax.IdentifierName(name));
            ReturnStatementSyntax rs = Syntax.ReturnStatement(memAcc);
            SyntaxList<ReturnStatementSyntax> list = Syntax.List(rs);
            BlockSyntax block = Syntax.Block(list);
            AccessorDeclarationSyntax acc = Syntax.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration, block);

            PropertyDeclarationSyntax pd = Syntax.PropertyDeclaration(null,
                Syntax.TokenList(new SyntaxToken[] { Syntax.Token(SyntaxKind.PublicKeyword), Syntax.Token(SyntaxKind.OverrideKeyword) }),
                Syntax.ParseTypeName(returnType.FullName + "[]"),
                null,
                Syntax.Identifier(propertyIdentifierName),
                Syntax.AccessorList(Syntax.List(acc)));

            return pd;
        }
        private PropertyDeclarationSyntax CreateStringProperty(string propertyIdentifierName, string targetFieldName, string startType, SyntaxList<MemberDeclarationSyntax> syntaxList, DynamicPlugin dp)
        {
            List<string> path = dp.FindStringPath(targetFieldName, startType);
            string name = "";
            if (path.Count == 1)
            {
                name = path.First();
            }
            else if (path.Count > 1)
            {
                foreach (string obj in path.Skip(1).Take(path.Count - 1))
                {
                    string val = "";
                    foreach (ClassDeclarationSyntax classes in syntaxList.Where(m => m is ClassDeclarationSyntax))
                    {
                        foreach (PropertyDeclarationSyntax prop in classes.Members.Where(m => m is PropertyDeclarationSyntax))
                        {
                            if (prop.Type.ToString().Contains(obj + "[]"))
                            {
                                val = prop.Identifier.ToString();
                                break;
                            }
                        }
                        if (val != "")
                            break;
                    }
                    if (val != "")
                        name += val + "[0].";
                }
                name += path.Last();
            }
            ExpressionSyntax expr;
            if (name != "")
                expr = Syntax.MemberAccessExpression(SyntaxKind.MemberAccessExpression, Syntax.ThisExpression(), Syntax.IdentifierName(name));
            else
                expr = Syntax.BaseExpression(Syntax.Token(SyntaxKind.NullKeyword));
            ReturnStatementSyntax rs = Syntax.ReturnStatement(expr);
            SyntaxList<ReturnStatementSyntax> list = Syntax.List(rs);
            BlockSyntax block = Syntax.Block(list);
            AccessorDeclarationSyntax acc = Syntax.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration, block);
            PropertyDeclarationSyntax pd2 = Syntax.PropertyDeclaration(null,
                Syntax.TokenList(new SyntaxToken[] { Syntax.Token(SyntaxKind.PublicKeyword), Syntax.Token(SyntaxKind.OverrideKeyword) }),
                Syntax.ParseTypeName("string"),
                null,
                Syntax.Identifier(propertyIdentifierName),
                Syntax.AccessorList(Syntax.List(acc)));

            return pd2;
        }
        private bool LoadCSIntoAssembly(string csFile)
        {
            string dll = csFile.Replace(".cs", ".dll");

            IEnumerable<SyntaxTree> syns = new List<SyntaxTree>() { SyntaxTree.ParseFile(csFile) };
            IEnumerable<Roslyn.Compilers.MetadataFileReference> assms = new List<Roslyn.Compilers.MetadataFileReference>() { 
                new Roslyn.Compilers.MetadataFileReference(typeof(DynamicPlugin).Assembly.Location),
                new Roslyn.Compilers.MetadataFileReference(typeof(String).Assembly.Location),
                new Roslyn.Compilers.MetadataFileReference(typeof(System.Xml.XmlWriter).Assembly.Location),
                new Roslyn.Compilers.MetadataFileReference(typeof(System.CodeDom.MemberAttributes).Assembly.Location),
                new Roslyn.Compilers.MetadataFileReference(typeof(System.ComponentModel.LicenseUsageMode).Assembly.Location)
            };

            Compilation comp = Compilation.Create(
                outputName: Path.GetFileName(dll),
                options: new CompilationOptions(Roslyn.Compilers.OutputKind.DynamicallyLinkedLibrary),
                syntaxTrees: syns,
                references: assms);

            EmitResult result = comp.Emit(dll);
            if (!result.Success)
            {
                StringBuilder sb = new StringBuilder();
                foreach (Diagnostic d in result.Diagnostics)
                {
                    sb.AppendLine(d.Info.GetMessage());
                }
                System.IO.File.WriteAllText(csFile.Replace(".cs", ".error"), sb.ToString());
            }
            return result.Success;
        }



        //copied directly from ReportController with changes to work with plugin. Same functionality
        public ActionResult Delete(DeleteMessageId? message)
        {
            //Cookie cutter from Controllers/AccountControlller.cs, just changed to work with plugins.
            //Question mark is to allow for null values.
            //Good description here http://stackoverflow.com/questions/446835/what-do-two-question-marks-together-mean-in-c
            ViewBag.StatusMessage =
            message == DeleteMessageId.RemovePluginSuccess ? "Your Plugin was successfully removed."
            : message == DeleteMessageId.RemovePluginFailure ? "Your Plugin was not successfully removed."
            : "";

            ViewBag.StatusFailure =
                message == DeleteMessageId.PluginErrorMessage ? "There was an error deleting your plugin, please try again."
                : "";

            Entities db = new Entities();

            var pluginIdConverter = db.Plugins.Local;

            //string pluginIdToString = pluginIdConverter.Select(c => c.PluginID).ToString();
            
            var query = db.Plugins.Select(c => new SelectListItem
            {
                Value = c.PluginGenerated,
                Text = c.PluginName
            });

            var model = new PluginDropDown
            {
                deleteList = query.ToList()
            };
            return View(model);
        }

        [HttpPost]
        [ValidateAntiForgeryToken]
        public ActionResult Delete(PluginDropDown pluginToDelete )
        {
            //TODO: Fix...
            if (ModelState.IsValid)
            {
                Entities db = new Entities();
                Plugin databasePlugin;

                try
                {
                    
                    databasePlugin = db.Plugins.Where(p => p.PluginGenerated == pluginToDelete.PluginGenerated).First();
                }
                catch
                {
                    return RedirectToAction("Delete", "Plugin", new { Message = DeleteMessageId.PluginErrorMessage });
                }
                //retrieve string to delete file off server

                //update database first
                db.Plugins.Remove(databasePlugin);
                db.SaveChanges();

                //if (System.IO.File.Exists(databasePluginFilePath))
                //{
                //    try
                //    {
                //        System.IO.File.Delete(databasePluginFilePath);

                //        return RedirectToAction("Delete", "Plugin", new { Message = DeleteMessageId.RemovePluginSuccess });
                //    }
                //    catch
                //    {
                //        return RedirectToAction("Delete", "Plugin", new { Message = DeleteMessageId.RemovePluginFailure });
                //    }
                //}

            }

            //Default return. Once functionality is complete, this return should only be reached if something goes wrong
            return View("Delete");
        }

        //Also cookie cutter
        public enum UploadMessageId
        {
            UploadPluginSuccess,
            UploadPluginFailure,
            PluginErrorMessage,
            PluginPathError,
            PluginExistsError,
            UserNotFound
        }

        public enum DeleteMessageId
        {
            RemovePluginSuccess,
            RemovePluginFailure,
            PluginErrorMessage
        }




    }
}
